/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v1.5.6
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2022-04-04T03:54:41+00:00 
 *
 * The version of the OpenAPI document: 1.5.6
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AttachmentArray,
    AttachmentArrayFromJSON,
    AttachmentArrayToJSON,
    Category,
    CategoryFromJSON,
    CategoryToJSON,
    CategoryArray,
    CategoryArrayFromJSON,
    CategoryArrayToJSON,
    CategorySingle,
    CategorySingleFromJSON,
    CategorySingleToJSON,
    CategoryUpdate,
    CategoryUpdateFromJSON,
    CategoryUpdateToJSON,
    TransactionArray,
    TransactionArrayFromJSON,
    TransactionArrayToJSON,
    TransactionTypeFilter,
    TransactionTypeFilterFromJSON,
    TransactionTypeFilterToJSON,
    ValidationError,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models';

export interface DeleteCategoryRequest {
    id: string;
}

export interface GetCategoryRequest {
    id: string;
    start?: Date;
    end?: Date;
}

export interface ListAttachmentByCategoryRequest {
    id: string;
    page?: number;
}

export interface ListCategoryRequest {
    page?: number;
}

export interface ListTransactionByCategoryRequest {
    id: string;
    page?: number;
    start?: Date;
    end?: Date;
    type?: TransactionTypeFilter;
}

export interface ListTransactionWithoutCategoryRequest {
    limit?: number;
    page?: number;
    start?: Date;
    end?: Date;
    type?: TransactionTypeFilter;
}

export interface StoreCategoryRequest {
    category: Category;
}

export interface UpdateCategoryRequest {
    id: string;
    categoryUpdate: CategoryUpdate;
}

/**
 * 
 */
export class CategoriesApi extends runtime.BaseAPI {

    /**
     * Delete a category. Transactions will not be removed.
     * Delete a category.
     */
    async deleteCategoryRaw(requestParameters: DeleteCategoryRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteCategory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("firefly_iii_auth", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/categories/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a category. Transactions will not be removed.
     * Delete a category.
     */
    async deleteCategory(requestParameters: DeleteCategoryRequest): Promise<void> {
        await this.deleteCategoryRaw(requestParameters);
    }

    /**
     * Get a single category.
     * Get a single category.
     */
    async getCategoryRaw(requestParameters: GetCategoryRequest): Promise<runtime.ApiResponse<CategorySingle>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getCategory.');
        }

        const queryParameters: any = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = (requestParameters.start as any).toISOString().substr(0,10);
        }

        if (requestParameters.end !== undefined) {
            queryParameters['end'] = (requestParameters.end as any).toISOString().substr(0,10);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("firefly_iii_auth", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/categories/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CategorySingleFromJSON(jsonValue));
    }

    /**
     * Get a single category.
     * Get a single category.
     */
    async getCategory(requestParameters: GetCategoryRequest): Promise<CategorySingle> {
        const response = await this.getCategoryRaw(requestParameters);
        return await response.value();
    }

    /**
     * Lists all attachments.
     * Lists all attachments.
     */
    async listAttachmentByCategoryRaw(requestParameters: ListAttachmentByCategoryRequest): Promise<runtime.ApiResponse<AttachmentArray>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling listAttachmentByCategory.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("firefly_iii_auth", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/categories/{id}/attachments`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AttachmentArrayFromJSON(jsonValue));
    }

    /**
     * Lists all attachments.
     * Lists all attachments.
     */
    async listAttachmentByCategory(requestParameters: ListAttachmentByCategoryRequest): Promise<AttachmentArray> {
        const response = await this.listAttachmentByCategoryRaw(requestParameters);
        return await response.value();
    }

    /**
     * List all categories.
     * List all categories.
     */
    async listCategoryRaw(requestParameters: ListCategoryRequest): Promise<runtime.ApiResponse<CategoryArray>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("firefly_iii_auth", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/categories`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CategoryArrayFromJSON(jsonValue));
    }

    /**
     * List all categories.
     * List all categories.
     */
    async listCategory(requestParameters: ListCategoryRequest): Promise<CategoryArray> {
        const response = await this.listCategoryRaw(requestParameters);
        return await response.value();
    }

    /**
     * List all transactions in a category, optionally limited to the date ranges specified.
     * List all transactions in a category.
     */
    async listTransactionByCategoryRaw(requestParameters: ListTransactionByCategoryRequest): Promise<runtime.ApiResponse<TransactionArray>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling listTransactionByCategory.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = (requestParameters.start as any).toISOString().substr(0,10);
        }

        if (requestParameters.end !== undefined) {
            queryParameters['end'] = (requestParameters.end as any).toISOString().substr(0,10);
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("firefly_iii_auth", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/categories/{id}/transactions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionArrayFromJSON(jsonValue));
    }

    /**
     * List all transactions in a category, optionally limited to the date ranges specified.
     * List all transactions in a category.
     */
    async listTransactionByCategory(requestParameters: ListTransactionByCategoryRequest): Promise<TransactionArray> {
        const response = await this.listTransactionByCategoryRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get all transactions without a category, possibly limited by start and end
     * All transactions without a category.
     */
    async listTransactionWithoutCategoryRaw(requestParameters: ListTransactionWithoutCategoryRequest): Promise<runtime.ApiResponse<TransactionArray>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = (requestParameters.start as any).toISOString().substr(0,10);
        }

        if (requestParameters.end !== undefined) {
            queryParameters['end'] = (requestParameters.end as any).toISOString().substr(0,10);
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("firefly_iii_auth", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/categories/transactions-without-category`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionArrayFromJSON(jsonValue));
    }

    /**
     * Get all transactions without a category, possibly limited by start and end
     * All transactions without a category.
     */
    async listTransactionWithoutCategory(requestParameters: ListTransactionWithoutCategoryRequest): Promise<TransactionArray> {
        const response = await this.listTransactionWithoutCategoryRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
     * Store a new category
     */
    async storeCategoryRaw(requestParameters: StoreCategoryRequest): Promise<runtime.ApiResponse<CategorySingle>> {
        if (requestParameters.category === null || requestParameters.category === undefined) {
            throw new runtime.RequiredError('category','Required parameter requestParameters.category was null or undefined when calling storeCategory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("firefly_iii_auth", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/categories`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CategoryToJSON(requestParameters.category),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CategorySingleFromJSON(jsonValue));
    }

    /**
     * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
     * Store a new category
     */
    async storeCategory(requestParameters: StoreCategoryRequest): Promise<CategorySingle> {
        const response = await this.storeCategoryRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update existing category.
     * Update existing category.
     */
    async updateCategoryRaw(requestParameters: UpdateCategoryRequest): Promise<runtime.ApiResponse<CategorySingle>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateCategory.');
        }

        if (requestParameters.categoryUpdate === null || requestParameters.categoryUpdate === undefined) {
            throw new runtime.RequiredError('categoryUpdate','Required parameter requestParameters.categoryUpdate was null or undefined when calling updateCategory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("firefly_iii_auth", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/categories/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CategoryUpdateToJSON(requestParameters.categoryUpdate),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CategorySingleFromJSON(jsonValue));
    }

    /**
     * Update existing category.
     * Update existing category.
     */
    async updateCategory(requestParameters: UpdateCategoryRequest): Promise<CategorySingle> {
        const response = await this.updateCategoryRaw(requestParameters);
        return await response.value();
    }

}
